"use strict";
/// <reference types="emscripten" />
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.SoxrResamplerTransform = exports.SoxrQuality = exports.SoxrDatatype = void 0;
const stream_1 = require("stream");
const soxr_wasm_1 = __importDefault(require("./soxr_wasm"));
var SoxrDatatype;
(function (SoxrDatatype) {
    SoxrDatatype[SoxrDatatype["SOXR_FLOAT32"] = 0] = "SOXR_FLOAT32";
    SoxrDatatype[SoxrDatatype["SOXR_FLOAT64"] = 1] = "SOXR_FLOAT64";
    SoxrDatatype[SoxrDatatype["SOXR_INT32"] = 2] = "SOXR_INT32";
    SoxrDatatype[SoxrDatatype["SOXR_INT16"] = 3] = "SOXR_INT16";
})(SoxrDatatype = exports.SoxrDatatype || (exports.SoxrDatatype = {}));
;
var SoxrQuality;
(function (SoxrQuality) {
    SoxrQuality[SoxrQuality["SOXR_QQ"] = 0] = "SOXR_QQ";
    SoxrQuality[SoxrQuality["SOXR_LQ"] = 1] = "SOXR_LQ";
    SoxrQuality[SoxrQuality["SOXR_MQ"] = 2] = "SOXR_MQ";
    SoxrQuality[SoxrQuality["SOXR_HQ"] = 4] = "SOXR_HQ";
    SoxrQuality[SoxrQuality["SOXR_VHQ"] = 6] = "SOXR_VHQ";
})(SoxrQuality = exports.SoxrQuality || (exports.SoxrQuality = {}));
let soxrModule;
let globalModulePromise = soxr_wasm_1.default().then((s) => soxrModule = s);
const bytesPerDatatypeSample = {
    [SoxrDatatype.SOXR_FLOAT32]: 4,
    [SoxrDatatype.SOXR_FLOAT64]: 8,
    [SoxrDatatype.SOXR_INT32]: 4,
    [SoxrDatatype.SOXR_INT16]: 2,
};
class SoxrResampler {
    /**
      * Create an SpeexResampler tranform stream.
      * @param channels Number of channels, minimum is 1, no maximum
      * @param inRate frequency in Hz for the input chunk
      * @param outRate frequency in Hz for the target chunk
      * @param dataType type of the input and output data, 0 = Float32, 1 = Float64, 2 = Int32, 3 = Int16
      * @param quality quality of the resampling, higher means more CPU usage, number between 0 and 6
      */
    constructor(channels, inRate, outRate, dataType = SoxrDatatype.SOXR_FLOAT32, quality = SoxrQuality.SOXR_HQ) {
        this.channels = channels;
        this.inRate = inRate;
        this.outRate = outRate;
        this.dataType = dataType;
        this.quality = quality;
        this._inBufferPtr = -1;
        this._inBufferSize = -1;
        this._outBufferPtr = -1;
        this._outBufferSize = -1;
        this._inProcessedLenPtr = -1;
        this._outProcessLenPtr = -1;
    }
    /**
      * Resample a chunk of audio.
      * @param chunk interleaved PCM data in this.dataType type or null if flush is requested
      */
    processChunk(chunk) {
        if (!soxrModule) {
            throw new Error('You need to wait for SoxrResampler.initPromise before calling this method');
        }
        // We check that we have as many chunks for each channel and that the last chunk is full (2 bytes)
        if (chunk && chunk.length % (this.channels * bytesPerDatatypeSample[this.dataType]) !== 0) {
            throw new Error(`Chunk length should be a multiple of channels * ${bytesPerDatatypeSample[this.dataType]} bytes`);
        }
        if (!this._resamplerPtr) {
            const ioSpecPtr = soxrModule._malloc(soxrModule._sizeof_soxr_io_spec_t());
            soxrModule._soxr_io_spec(ioSpecPtr, this.dataType, this.dataType);
            const qualitySpecPtr = soxrModule._malloc(soxrModule._sizeof_soxr_quality_spec_t());
            soxrModule._soxr_quality_spec(qualitySpecPtr, this.quality, 0);
            const errPtr = soxrModule._malloc(4);
            this._resamplerPtr = soxrModule._soxr_create(this.inRate, this.outRate, this.channels, errPtr, ioSpecPtr, qualitySpecPtr, 0);
            soxrModule._free(ioSpecPtr);
            soxrModule._free(qualitySpecPtr);
            const errNum = soxrModule.getValue(errPtr, 'i32');
            if (errNum !== 0) {
                const err = new Error(soxrModule.AsciiToString(errNum));
                soxrModule._free(errPtr);
                throw err;
            }
            this._inProcessedLenPtr = soxrModule._malloc(Uint32Array.BYTES_PER_ELEMENT);
            this._outProcessLenPtr = soxrModule._malloc(Uint32Array.BYTES_PER_ELEMENT);
        }
        if (chunk) {
            // Resizing the input buffer in the WASM memory space to match what we need
            if (this._inBufferSize < chunk.length) {
                if (this._inBufferPtr !== -1) {
                    soxrModule._free(this._inBufferPtr);
                }
                this._inBufferPtr = soxrModule._malloc(chunk.length);
                this._inBufferSize = chunk.length;
            }
            // Resizing the output buffer in the WASM memory space to match what we need
            const outBufferLengthTarget = Math.ceil(chunk.length * this.outRate / this.inRate);
            if (this._outBufferSize < outBufferLengthTarget) {
                if (this._outBufferPtr !== -1) {
                    soxrModule._free(this._outBufferPtr);
                }
                this._outBufferPtr = soxrModule._malloc(outBufferLengthTarget);
                this._outBufferSize = outBufferLengthTarget;
            }
            // Copying the info from the input Buffer in the WASM memory space
            soxrModule.HEAPU8.set(chunk, this._inBufferPtr);
        }
        // number of samples per channel in input buffer
        soxrModule.setValue(this._inProcessedLenPtr, 0, 'i32');
        // number of samples per channels available in output buffer
        soxrModule.setValue(this._outProcessLenPtr, 0, 'i32');
        const errPtr = soxrModule._soxr_process(this._resamplerPtr, chunk ? this._inBufferPtr : 0, chunk ? chunk.length / this.channels / bytesPerDatatypeSample[this.dataType] : 0, this._inProcessedLenPtr, this._outBufferPtr, this._outBufferSize / this.channels / bytesPerDatatypeSample[this.dataType], this._outProcessLenPtr);
        if (errPtr !== 0) {
            throw new Error(soxrModule.AsciiToString(errPtr));
        }
        const outSamplesPerChannelsWritten = soxrModule.getValue(this._outProcessLenPtr, 'i32');
        // we are copying the info in a new buffer here, we could just pass a buffer pointing to the same memory space if needed
        return Buffer.from(soxrModule.HEAPU8.slice(this._outBufferPtr, this._outBufferPtr + outSamplesPerChannelsWritten * this.channels * bytesPerDatatypeSample[this.dataType]).buffer);
    }
}
SoxrResampler.initPromise = globalModulePromise;
const EMPTY_BUFFER = Buffer.alloc(0);
class SoxrResamplerTransform extends stream_1.Transform {
    /**
      * Create an SpeexResampler instance.
      * @param channels Number of channels, minimum is 1, no maximum
      * @param inRate frequency in Hz for the input chunk
      * @param outRate frequency in Hz for the target chunk
      * @param dataType type of the input and output data, 0 = Float32, 1 = Float64, 2 = Int32, 3 = Int16
      * @param quality quality of the resampling, higher means more CPU usage, number between 0 and 6
      */
    constructor(channels, inRate, outRate, dataType = SoxrDatatype.SOXR_FLOAT32, quality = SoxrQuality.SOXR_HQ) {
        super();
        this.channels = channels;
        this.inRate = inRate;
        this.outRate = outRate;
        this.dataType = dataType;
        this.quality = quality;
        this.resampler = new SoxrResampler(channels, inRate, outRate, dataType, quality);
        this.channels = channels;
        this._alignementBuffer = EMPTY_BUFFER;
    }
    _transform(chunk, encoding, callback) {
        let chunkToProcess = chunk;
        if (this._alignementBuffer.length > 0) {
            chunkToProcess = Buffer.concat([
                this._alignementBuffer,
                chunk,
            ]);
            this._alignementBuffer = EMPTY_BUFFER;
        }
        // Speex needs a buffer aligned to 16bits times the number of channels
        // so we keep the extraneous bytes in a buffer for next chunk
        const extraneousBytesCount = chunkToProcess.length % (this.channels * Uint16Array.BYTES_PER_ELEMENT);
        if (extraneousBytesCount !== 0) {
            this._alignementBuffer = Buffer.from(chunkToProcess.slice(chunkToProcess.length - extraneousBytesCount));
            chunkToProcess = chunkToProcess.slice(0, chunkToProcess.length - extraneousBytesCount);
        }
        try {
            const res = this.resampler.processChunk(chunkToProcess);
            callback(null, res);
        }
        catch (e) {
            callback(e);
        }
    }
    _flush(callback) {
        try {
            const res = this.resampler.processChunk(null);
            callback(null, res);
        }
        catch (e) {
            callback(e);
        }
    }
}
exports.SoxrResamplerTransform = SoxrResamplerTransform;
exports.default = SoxrResampler;
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiaW5kZXguanMiLCJzb3VyY2VSb290IjoiLyIsInNvdXJjZXMiOlsiaW5kZXgudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IjtBQUFBLG9DQUFvQzs7Ozs7O0FBRXBDLG1DQUFtQztBQUNuQyw0REFBbUM7QUFFbkMsSUFBWSxZQUtYO0FBTEQsV0FBWSxZQUFZO0lBQ3RCLCtEQUFnQixDQUFBO0lBQ2hCLCtEQUFnQixDQUFBO0lBQ2hCLDJEQUFjLENBQUE7SUFDZCwyREFBYyxDQUFBO0FBQ2hCLENBQUMsRUFMVyxZQUFZLEdBQVosb0JBQVksS0FBWixvQkFBWSxRQUt2QjtBQUFBLENBQUM7QUFFRixJQUFZLFdBTVg7QUFORCxXQUFZLFdBQVc7SUFDckIsbURBQVcsQ0FBQTtJQUNYLG1EQUFXLENBQUE7SUFDWCxtREFBVyxDQUFBO0lBQ1gsbURBQVcsQ0FBQTtJQUNYLHFEQUFZLENBQUE7QUFDZCxDQUFDLEVBTlcsV0FBVyxHQUFYLG1CQUFXLEtBQVgsbUJBQVcsUUFNdEI7QUFvQ0QsSUFBSSxVQUF1QyxDQUFDO0FBQzVDLElBQUksbUJBQW1CLEdBQUcsbUJBQVEsRUFBRSxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFLENBQUMsVUFBVSxHQUFHLENBQUMsQ0FBQyxDQUFDO0FBRWpFLE1BQU0sc0JBQXNCLEdBQUc7SUFDN0IsQ0FBQyxZQUFZLENBQUMsWUFBWSxDQUFDLEVBQUUsQ0FBQztJQUM5QixDQUFDLFlBQVksQ0FBQyxZQUFZLENBQUMsRUFBRSxDQUFDO0lBQzlCLENBQUMsWUFBWSxDQUFDLFVBQVUsQ0FBQyxFQUFFLENBQUM7SUFDNUIsQ0FBQyxZQUFZLENBQUMsVUFBVSxDQUFDLEVBQUUsQ0FBQztDQUM3QixDQUFDO0FBRUYsTUFBTSxhQUFhO0lBWWpCOzs7Ozs7O1FBT0k7SUFDSixZQUNTLFFBQVEsRUFDUixNQUFNLEVBQ04sT0FBTyxFQUNQLFdBQVcsWUFBWSxDQUFDLFlBQVksRUFDcEMsVUFBVSxXQUFXLENBQUMsT0FBTztRQUo3Qixh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Q0FBQyxLQUFLLENBQUMsQ0FBQyxFQUFFLGNBQWMsQ0FBQyxNQUFNLEdBQUcsb0JBQW9CLENBQUMsQ0FBQztTQUN4RjtRQUNELElBQUk7WUFDRixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxjQUFjLENBQUMsQ0FBQztZQUN4RCxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ3JCO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDYjtJQUNILENBQUM7SUFFRCxNQUFNLENBQUMsUUFBUTtRQUNiLElBQUk7WUFDRixNQUFNLEdBQUcsR0FBRyxJQUFJLENBQUMsU0FBUyxDQUFDLFlBQVksQ0FBQyxJQUFJLENBQUMsQ0FBQztZQUM5QyxRQUFRLENBQUMsSUFBSSxFQUFFLEdBQUcsQ0FBQyxDQUFDO1NBQ3JCO1FBQUMsT0FBTyxDQUFDLEVBQUU7WUFDVixRQUFRLENBQUMsQ0FBQyxDQUFDLENBQUM7U0FDYjtJQUNILENBQUM7Q0FDRjtBQXpERCx3REF5REM7QUFFRCxrQkFBZSxhQUFhLENBQUMiLCJzb3VyY2VzQ29udGVudCI6WyIvLy8gPHJlZmVyZW5jZSB0eXBlcz1cImVtc2NyaXB0ZW5cIiAvPlxuXG5pbXBvcnQgeyBUcmFuc2Zvcm0gfSBmcm9tICdzdHJlYW0nO1xuaW1wb3J0IFNveHJXYXNtIGZyb20gJy4vc294cl93YXNtJztcblxuZXhwb3J0IGVudW0gU294ckRhdGF0eXBlIHtcbiAgU09YUl9GTE9BVDMyID0gMCxcbiAgU09YUl9GTE9BVDY0ID0gMSxcbiAgU09YUl9JTlQzMiA9IDIsXG4gIFNPWFJfSU5UMTYgPSAzLFxufTtcblxuZXhwb3J0IGVudW0gU294clF1YWxpdHkge1xuICBTT1hSX1FRID0gMCxcbiAgU09YUl9MUSA9IDEsXG4gIFNPWFJfTVEgPSAyLFxuICBTT1hSX0hRID0gNCxcbiAgU09YUl9WSFEgPSA2LFxufVxuXG5pbnRlcmZhY2UgRW1zY3JpcHRlbk1vZHVsZU9wdXNFbmNvZGVyIGV4dGVuZHMgRW1zY3JpcHRlbk1vZHVsZSB7XG4gIF9zb3hyX2NyZWF0ZShcbiAgICBpbnB1dFJhdGU6IG51bWJlcixcbiAgICBvdXRwdXRSYXRlOiBudW1iZXIsXG4gICAgbnVtX2NoYW5uZWxzOiBudW1iZXIsXG4gICAgZXJyUHRyOiBudW1iZXIsXG4gICAgaW9TcGVjUHRyOiBudW1iZXIsXG4gICAgcXVhbGl0eVNwZWNQdHI6IG51bWJlcixcbiAgICBydW50aW1lU3BlY1B0cjogbnVtYmVyLFxuICApOiBudW1iZXI7XG4gIF9zb3hyX2RlbGV0ZShyZXNhbXBsZXJQdHI6IG51bWJlcik6IHZvaWQ7XG4gIF9zb3hyX3Byb2Nlc3MoXG4gICAgcmVzYW1wbGVyUHRyOiBudW1iZXIsXG4gICAgaW5CdWZQdHI6IG51bWJlcixcbiAgICBpbkxlbjogbnVtYmVyLFxuICAgIGluQ29uc3VtbWVkTGVuUHRyOiBudW1iZXIsXG4gICAgb3V0QnVmUHRyOiBudW1iZXIsXG4gICAgb3V0TGVuOiBudW1iZXIsXG4gICAgb3V0RW1pdHRlZExlblB0cjogbnVtYmVyLFxuICApOiBudW1iZXI7XG4gIF9zb3hyX2lvX3NwZWMoXG4gICAgaW9TcGVjUHRyOiBudW1iZXIsXG4gICAgaXR5cGU6IG51bWJlcixcbiAgICBvdHlwZTogbnVtYmVyLFxuICApOiB2b2lkO1xuICBfc294cl9xdWFsaXR5X3NwZWMocXVhbGl0eVNwZWNQdHI6IG51bWJlciwgcmVjaXBlOiBudW1iZXIsIGZsYWdzOiBudW1iZXIpOiB2b2lkO1xuICBfc2l6ZW9mX3NveHJfaW9fc3BlY190KCk6IG51bWJlcjtcbiAgX3NpemVvZl9zb3hyX3F1YWxpdHlfc3BlY190KCk6IG51bWJlcjtcblxuICBnZXRWYWx1ZShwdHI6IG51bWJlciwgdHlwZTogc3RyaW5nKTogYW55O1xuICBzZXRWYWx1ZShwdHI6IG51bWJlciwgdmFsdWU6IGFueSwgdHlwZTogc3RyaW5nKTogYW55O1xuICBBc2NpaVRvU3RyaW5nKHB0cjogbnVtYmVyKTogc3RyaW5nO1xufVxuXG5sZXQgc294ck1vZHVsZTogRW1zY3JpcHRlbk1vZHVsZU9wdXNFbmNvZGVyO1xubGV0IGdsb2JhbE1vZHVsZVByb21pc2UgPSBTb3hyV2FzbSgpLnRoZW4oKHMpID0+IHNveHJNb2R1bGUgPSBzKTtcblxuY29uc3QgYnl0ZXNQZXJEYXRhdHlwZVNhbXBsZSA9IHtcbiAgW1NveHJEYXRhdHlwZS5TT1hSX0ZMT0FUMzJdOiA0LFxuICBbU294ckRhdGF0eXBlLlNPWFJfRkxPQVQ2NF06IDgsXG4gIFtTb3hyRGF0YXR5cGUuU09YUl9JTlQzMl06IDQsXG4gIFtTb3hyRGF0YXR5cGUuU09YUl9JTlQxNl06IDIsXG59O1xuXG5jbGFzcyBTb3hyUmVzYW1wbGVyIHtcbiAgX3Jlc2FtcGxlclB0cjogbnVtYmVyO1xuICBfaW5CdWZmZXJQdHIgPSAtMTtcbiAgX2luQnVmZmVyU2l6ZSA9IC0xO1xuICBfb3V0QnVmZmVyUHRyID0gLTE7XG4gIF9vdXRCdWZmZXJTaXplID0gLTE7XG5cbiAgX2luUHJvY2Vzc2VkTGVuUHRyID0gLTE7XG4gIF9vdXRQcm9jZXNzTGVuUHRyID0gLTE7XG5cbiAgc3RhdGljIGluaXRQcm9taXNlID0gZ2xvYmFsTW9kdWxlUHJvbWlzZSBhcyBQcm9taXNlPGFueT47XG5cbiAgLyoqXG4gICAgKiBDcmVhdGUgYW4gU3BlZXhSZXNhbXBsZXIgdHJhbmZvcm0gc3RyZWFtLlxuICAgICogQHBhcmFtIGNoYW5uZWxzIE51bWJlciBvZiBjaGFubmVscywgbWluaW11bSBpcyAxLCBubyBtYXhpbXVtXG4gICAgKiBAcGFyYW0gaW5SYXRlIGZyZXF1ZW5jeSBpbiBIeiBmb3IgdGhlIGlucHV0IGNodW5rXG4gICAgKiBAcGFyYW0gb3V0UmF0ZSBmcmVxdWVuY3kgaW4gSHogZm9yIHRoZSB0YXJnZXQgY2h1bmtcbiAgICAqIEBwYXJhbSBkYXRhVHlwZSB0eXBlIG9mIHRoZSBpbnB1dCBhbmQgb3V0cHV0IGRhdGEsIDAgPSBGbG9hdDMyLCAxID0gRmxvYXQ2NCwgMiA9IEludDMyLCAzID0gSW50MTZcbiAgICAqIEBwYXJhbSBxdWFsaXR5IHF1YWxpdHkgb2YgdGhlIHJlc2FtcGxpbmcsIGhpZ2hlciBtZWFucyBtb3JlIENQVSB1c2FnZSwgbnVtYmVyIGJldHdlZW4gMCBhbmQgNlxuICAgICovXG4gIGNvbnN0cnVjdG9yKFxuICAgIHB1YmxpYyBjaGFubmVscyxcbiAgICBwdWJsaWMgaW5SYXRlLFxuICAgIHB1YmxpYyBvdXRSYXRlLFxuICAgIHB1YmxpYyBkYXRhVHlwZSA9IFNveHJEYXRhdHlwZS5TT1hSX0ZMT0FUMzIsXG4gICAgcHVibGljIHF1YWxpdHkgPSBTb3hyUXVhbGl0eS5TT1hSX0hRLFxuICApIHt9XG5cbiAgLyoqXG4gICAgKiBSZXNhbXBsZSBhIGNodW5rIG9mIGF1ZGlvLlxuICAgICogQHBhcmFtIGNodW5rIGludGVybGVhdmVkIFBDTSBkYXRhIGluIHRoaXMuZGF0YVR5cGUgdHlwZSBvciBudWxsIGlmIGZsdXNoIGlzIHJlcXVlc3RlZFxuICAgICovXG4gIHByb2Nlc3NDaHVuayhjaHVuazogQnVmZmVyKSB7XG4gICAgaWYgKCFzb3hyTW9kdWxlKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ1lvdSBuZWVkIHRvIHdhaXQgZm9yIFNveHJSZXNhbXBsZXIuaW5pdFByb21pc2UgYmVmb3JlIGNhbGxpbmcgdGhpcyBtZXRob2QnKTtcbiAgICB9XG4gICAgLy8gV2UgY2hlY2sgdGhhdCB3ZSBoYXZlIGFzIG1hbnkgY2h1bmtzIGZvciBlYWNoIGNoYW5uZWwgYW5kIHRoYXQgdGhlIGxhc3QgY2h1bmsgaXMgZnVsbCAoMiBieXRlcylcbiAgICBpZiAoY2h1bmsgJiYgY2h1bmsubGVuZ3RoICUgKHRoaXMuY2hhbm5lbHMgKiBieXRlc1BlckRhdGF0eXBlU2FtcGxlW3RoaXMuZGF0YVR5cGVdKSAhPT0gMCkge1xuICAgICAgdGhyb3cgbmV3IEVycm9yKGBDaHVuayBsZW5ndGggc2hvdWxkIGJlIGEgbXVsdGlwbGUgb2YgY2hhbm5lbHMgKiAke2J5dGVzUGVyRGF0YXR5cGVTYW1wbGVbdGhpcy5kYXRhVHlwZV19IGJ5dGVzYCk7XG4gICAgfVxuXG4gICAgaWYgKCF0aGlzLl9yZXNhbXBsZXJQdHIpIHtcbiAgICAgIGNvbnN0IGlvU3BlY1B0ciA9IHNveHJNb2R1bGUuX21hbGxvYyhzb3hyTW9kdWxlLl9zaXplb2Zfc294cl9pb19zcGVjX3QoKSk7XG4gICAgICBzb3hyTW9kdWxlLl9zb3hyX2lvX3NwZWMoaW9TcGVjUHRyLCB0aGlzLmRhdGFUeXBlLCB0aGlzLmRhdGFUeXBlKTtcbiAgICAgIGNvbnN0IHF1YWxpdHlTcGVjUHRyID0gc294ck1vZHVsZS5fbWFsbG9jKHNveHJNb2R1bGUuX3NpemVvZl9zb3hyX3F1YWxpdHlfc3BlY190KCkpO1xuICAgICAgc294ck1vZHVsZS5fc294cl9xdWFsaXR5X3NwZWMocXVhbGl0eVNwZWNQdHIsIHRoaXMucXVhbGl0eSwgMCk7XG4gICAgICBjb25zdCBlcnJQdHIgPSBzb3hyTW9kdWxlLl9tYWxsb2MoNCk7XG4gICAgICB0aGlzLl9yZXNhbXBsZXJQdHIgPSBzb3hyTW9kdWxlLl9zb3hyX2NyZWF0ZShcbiAgICAgICAgdGhpcy5pblJhdGUsXG4gICAgICAgIHRoaXMub3V0UmF0ZSxcbiAgICAgICAgdGhpcy5jaGFubmVscyxcbiAgICAgICAgZXJyUHRyLFxuICAgICAgICBpb1NwZWNQdHIsXG4gICAgICAgIHF1YWxpdHlTcGVjUHRyLFxuICAgICAgICAwLFxuICAgICAgKTtcbiAgICAgIHNveHJNb2R1bGUuX2ZyZWUoaW9TcGVjUHRyKTtcbiAgICAgIHNveHJNb2R1bGUuX2ZyZWUocXVhbGl0eVNwZWNQdHIpO1xuICAgICAgY29uc3QgZXJyTnVtID0gc294ck1vZHVsZS5nZXRWYWx1ZShlcnJQdHIsICdpMzInKTtcbiAgICAgIGlmIChlcnJOdW0gIT09IDApIHtcbiAgICAgICAgY29uc3QgZXJyID0gIG5ldyBFcnJvcihzb3hyTW9kdWxlLkFzY2lpVG9TdHJpbmcoZXJyTnVtKSk7XG4gICAgICAgIHNveHJNb2R1bGUuX2ZyZWUoZXJyUHRyKTtcbiAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgfVxuICAgICAgdGhpcy5faW5Qcm9jZXNzZWRMZW5QdHIgPSBzb3hyTW9kdWxlLl9tYWxsb2MoVWludDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQpO1xuICAgICAgdGhpcy5fb3V0UHJvY2Vzc0xlblB0ciA9IHNveHJNb2R1bGUuX21hbGxvYyhVaW50MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgfVxuXG4gICAgaWYgKGNodW5rKSB7XG4gICAgICAvLyBSZXNpemluZyB0aGUgaW5wdXQgYnVmZmVyIGluIHRoZSBXQVNNIG1lbW9yeSBzcGFjZSB0byBtYXRjaCB3aGF0IHdlIG5lZWRcbiAgICAgIGlmICh0aGlzLl9pbkJ1ZmZlclNpemUgPCBjaHVuay5sZW5ndGgpIHtcbiAgICAgICAgaWYgKHRoaXMuX2luQnVmZmVyUHRyICE9PSAtMSkge1xuICAgICAgICAgIHNveHJNb2R1bGUuX2ZyZWUodGhpcy5faW5CdWZmZXJQdHIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2luQnVmZmVyUHRyID0gc294ck1vZHVsZS5fbWFsbG9jKGNodW5rLmxlbmd0aCk7XG4gICAgICAgIHRoaXMuX2luQnVmZmVyU2l6ZSA9IGNodW5rLmxlbmd0aDtcbiAgICAgIH1cblxuICAgICAgLy8gUmVzaXppbmcgdGhlIG91dHB1dCBidWZmZXIgaW4gdGhlIFdBU00gbWVtb3J5IHNwYWNlIHRvIG1hdGNoIHdoYXQgd2UgbmVlZFxuICAgICAgY29uc3Qgb3V0QnVmZmVyTGVuZ3RoVGFyZ2V0ID0gTWF0aC5jZWlsKGNodW5rLmxlbmd0aCAqIHRoaXMub3V0UmF0ZSAvIHRoaXMuaW5SYXRlKTtcbiAgICAgIGlmICh0aGlzLl9vdXRCdWZmZXJTaXplIDwgb3V0QnVmZmVyTGVuZ3RoVGFyZ2V0KSB7XG4gICAgICAgIGlmICh0aGlzLl9vdXRCdWZmZXJQdHIgIT09IC0xKSB7XG4gICAgICAgICAgc294ck1vZHVsZS5fZnJlZSh0aGlzLl9vdXRCdWZmZXJQdHIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX291dEJ1ZmZlclB0ciA9IHNveHJNb2R1bGUuX21hbGxvYyhvdXRCdWZmZXJMZW5ndGhUYXJnZXQpO1xuICAgICAgICB0aGlzLl9vdXRCdWZmZXJTaXplID0gb3V0QnVmZmVyTGVuZ3RoVGFyZ2V0O1xuICAgICAgfVxuXG4gICAgICAvLyBDb3B5aW5nIHRoZSBpbmZvIGZyb20gdGhlIGlucHV0IEJ1ZmZlciBpbiB0aGUgV0FTTSBtZW1vcnkgc3BhY2VcbiAgICAgIHNveHJNb2R1bGUuSEVBUFU4LnNldChjaHVuaywgdGhpcy5faW5CdWZmZXJQdHIpO1xuICAgIH1cblxuICAgIC8vIG51bWJlciBvZiBzYW1wbGVzIHBlciBjaGFubmVsIGluIGlucHV0IGJ1ZmZlclxuICAgIHNveHJNb2R1bGUuc2V0VmFsdWUodGhpcy5faW5Qcm9jZXNzZWRMZW5QdHIsIDAsICdpMzInKTtcblxuICAgIC8vIG51bWJlciBvZiBzYW1wbGVzIHBlciBjaGFubmVscyBhdmFpbGFibGUgaW4gb3V0cHV0IGJ1ZmZlclxuICAgIHNveHJNb2R1bGUuc2V0VmFsdWUodGhpcy5fb3V0UHJvY2Vzc0xlblB0ciwgMCwgJ2kzMicpO1xuICAgIGNvbnN0IGVyclB0ciA9IHNveHJNb2R1bGUuX3NveHJfcHJvY2VzcyhcbiAgICAgIHRoaXMuX3Jlc2FtcGxlclB0cixcbiAgICAgIGNodW5rID8gdGhpcy5faW5CdWZmZXJQdHIgOiAwLFxuICAgICAgY2h1bmsgPyBjaHVuay5sZW5ndGggLyB0aGlzLmNoYW5uZWxzIC8gYnl0ZXNQZXJEYXRhdHlwZVNhbXBsZVt0aGlzLmRhdGFUeXBlXSA6IDAsXG4gICAgICB0aGlzLl9pblByb2Nlc3NlZExlblB0cixcbiAgICAgIHRoaXMuX291dEJ1ZmZlclB0cixcbiAgICAgIHRoaXMuX291dEJ1ZmZlclNpemUgLyB0aGlzLmNoYW5uZWxzIC8gYnl0ZXNQZXJEYXRhdHlwZVNhbXBsZVt0aGlzLmRhdGFUeXBlXSxcbiAgICAgIHRoaXMuX291dFByb2Nlc3NMZW5QdHIsXG4gICAgKTtcblxuICAgIGlmIChlcnJQdHIgIT09IDApIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcihzb3hyTW9kdWxlLkFzY2lpVG9TdHJpbmcoZXJyUHRyKSk7XG4gICAgfVxuXG4gICAgY29uc3Qgb3V0U2FtcGxlc1BlckNoYW5uZWxzV3JpdHRlbiA9IHNveHJNb2R1bGUuZ2V0VmFsdWUodGhpcy5fb3V0UHJvY2Vzc0xlblB0ciwgJ2kzMicpO1xuICAgIC8vIHdlIGFyZSBjb3B5aW5nIHRoZSBpbmZvIGluIGEgbmV3IGJ1ZmZlciBoZXJlLCB3ZSBjb3VsZCBqdXN0IHBhc3MgYSBidWZmZXIgcG9pbnRpbmcgdG8gdGhlIHNhbWUgbWVtb3J5IHNwYWNlIGlmIG5lZWRlZFxuICAgIHJldHVybiBCdWZmZXIuZnJvbShcbiAgICAgIHNveHJNb2R1bGUuSEVBUFU4LnNsaWNlKFxuICAgICAgICB0aGlzLl9vdXRCdWZmZXJQdHIsXG4gICAgICAgIHRoaXMuX291dEJ1ZmZlclB0ciArIG91dFNhbXBsZXNQZXJDaGFubmVsc1dyaXR0ZW4gKiB0aGlzLmNoYW5uZWxzICogYnl0ZXNQZXJEYXRhdHlwZVNhbXBsZVt0aGlzLmRhdGFUeXBlXVxuICAgICAgKS5idWZmZXIpO1xuICB9XG59XG5cbmNvbnN0IEVNUFRZX0JVRkZFUiA9IEJ1ZmZlci5hbGxvYygwKTtcblxuZXhwb3J0IGNsYXNzIFNveHJSZXNhbXBsZXJUcmFuc2Zvcm0gZXh0ZW5kcyBUcmFuc2Zvcm0ge1xuICByZXNhbXBsZXI6IFNveHJSZXNhbXBsZXI7XG4gIF9hbGlnbmVtZW50QnVmZmVyOiBCdWZmZXI7XG5cbiAgLyoqXG4gICAgKiBDcmVhdGUgYW4gU3BlZXhSZXNhbXBsZXIgaW5zdGFuY2UuXG4gICAgKiBAcGFyYW0gY2hhbm5lbHMgTnVtYmVyIG9mIGNoYW5uZWxzLCBtaW5pbXVtIGlzIDEsIG5vIG1heGltdW1cbiAgICAqIEBwYXJhbSBpblJhdGUgZnJlcXVlbmN5IGluIEh6IGZvciB0aGUgaW5wdXQgY2h1bmtcbiAgICAqIEBwYXJhbSBvdXRSYXRlIGZyZXF1ZW5jeSBpbiBIeiBmb3IgdGhlIHRhcmdldCBjaHVua1xuICAgICogQHBhcmFtIGRhdGFUeXBlIHR5cGUgb2YgdGhlIGlucHV0IGFuZCBvdXRwdXQgZGF0YSwgMCA9IEZsb2F0MzIsIDEgPSBGbG9hdDY0LCAyID0gSW50MzIsIDMgPSBJbnQxNlxuICAgICogQHBhcmFtIHF1YWxpdHkgcXVhbGl0eSBvZiB0aGUgcmVzYW1wbGluZywgaGlnaGVyIG1lYW5zIG1vcmUgQ1BVIHVzYWdlLCBudW1iZXIgYmV0d2VlbiAwIGFuZCA2XG4gICAgKi9cbiAgY29uc3RydWN0b3IoXG4gICAgcHVibGljIGNoYW5uZWxzLFxuICAgIHB1YmxpYyBpblJhdGUsXG4gICAgcHVibGljIG91dFJhdGUsXG4gICAgcHVibGljIGRhdGFUeXBlID0gU294ckRhdGF0eXBlLlNPWFJfRkxPQVQzMixcbiAgICBwdWJsaWMgcXVhbGl0eSA9IFNveHJRdWFsaXR5LlNPWFJfSFEsXG4gICkge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5yZXNhbXBsZXIgPSBuZXcgU294clJlc2FtcGxlcihjaGFubmVscywgaW5SYXRlLCBvdXRSYXRlLCBkYXRhVHlwZSwgcXVhbGl0eSk7XG4gICAgdGhpcy5jaGFubmVscyA9IGNoYW5uZWxzO1xuICAgIHRoaXMuX2FsaWduZW1lbnRCdWZmZXIgPSBFTVBUWV9CVUZGRVI7XG4gIH1cblxuICBfdHJhbnNmb3JtKGNodW5rLCBlbmNvZGluZywgY2FsbGJhY2spIHtcbiAgICBsZXQgY2h1bmtUb1Byb2Nlc3M6IEJ1ZmZlciA9IGNodW5rO1xuICAgIGlmICh0aGlzLl9hbGlnbmVtZW50QnVmZmVyLmxlbmd0aCA+IDApIHtcbiAgICAgIGNodW5rVG9Qcm9jZXNzID0gQnVmZmVyLmNvbmNhdChbXG4gICAgICAgIHRoaXMuX2FsaWduZW1lbnRCdWZmZXIsXG4gICAgICAgIGNodW5rLFxuICAgICAgXSk7XG4gICAgICB0aGlzLl9hbGlnbmVtZW50QnVmZmVyID0gRU1QVFlfQlVGRkVSO1xuICAgIH1cbiAgICAvLyBTcGVleCBuZWVkcyBhIGJ1ZmZlciBhbGlnbmVkIHRvIDE2Yml0cyB0aW1lcyB0aGUgbnVtYmVyIG9mIGNoYW5uZWxzXG4gICAgLy8gc28gd2Uga2VlcCB0aGUgZXh0cmFuZW91cyBieXRlcyBpbiBhIGJ1ZmZlciBmb3IgbmV4dCBjaHVua1xuICAgIGNvbnN0IGV4dHJhbmVvdXNCeXRlc0NvdW50ID0gY2h1bmtUb1Byb2Nlc3MubGVuZ3RoICUgKHRoaXMuY2hhbm5lbHMgKiBVaW50MTZBcnJheS5CWVRFU19QRVJfRUxFTUVOVCk7XG4gICAgaWYgKGV4dHJhbmVvdXNCeXRlc0NvdW50ICE9PSAwKSB7XG4gICAgICB0aGlzLl9hbGlnbmVtZW50QnVmZmVyID0gQnVmZmVyLmZyb20oY2h1bmtUb1Byb2Nlc3Muc2xpY2UoY2h1bmtUb1Byb2Nlc3MubGVuZ3RoIC0gZXh0cmFuZW91c0J5dGVzQ291bnQpKTtcbiAgICAgIGNodW5rVG9Qcm9jZXNzID0gY2h1bmtUb1Byb2Nlc3Muc2xpY2UoMCwgY2h1bmtUb1Byb2Nlc3MubGVuZ3RoIC0gZXh0cmFuZW91c0J5dGVzQ291bnQpO1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgY29uc3QgcmVzID0gdGhpcy5yZXNhbXBsZXIucHJvY2Vzc0NodW5rKGNodW5rVG9Qcm9jZXNzKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgfVxuICB9XG5cbiAgX2ZsdXNoKGNhbGxiYWNrKSB7XG4gICAgdHJ5IHtcbiAgICAgIGNvbnN0IHJlcyA9IHRoaXMucmVzYW1wbGVyLnByb2Nlc3NDaHVuayhudWxsKTtcbiAgICAgIGNhbGxiYWNrKG51bGwsIHJlcyk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgY2FsbGJhY2soZSk7XG4gICAgfVxuICB9XG59XG5cbmV4cG9ydCBkZWZhdWx0IFNveHJSZXNhbXBsZXI7XG4iXX0=