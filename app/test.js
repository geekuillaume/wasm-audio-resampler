"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.parallelTest = exports.promiseBasedTest = void 0;
const fs_1 = require("fs");
// const {promisify} = require('util');
const perf_hooks_1 = require("perf_hooks");
const path_1 = __importDefault(require("path"));
const test_utils_1 = require("./test_utils");
const index_1 = __importStar(require("./index"));
const soxr_resampler_thread_1 = require("./soxr_resampler_thread");
const assert = (condition, message) => {
    if (!condition) {
        throw new Error(message);
    }
};
exports.promiseBasedTest = async () => {
    for (const audioTest of test_utils_1.audioTests) {
        const resampler = new index_1.default(audioTest.channels, audioTest.inRate, audioTest.outRate, index_1.SoxrDatatype.SOXR_INT16, index_1.SoxrDatatype.SOXR_INT16, audioTest.quality);
        await resampler.init();
        const filename = path_1.default.parse(audioTest.inFile).name;
        const start = perf_hooks_1.performance.now();
        const res = Buffer.concat([resampler.processChunk(audioTest.pcmData), resampler.processChunk(null)]);
        const end = perf_hooks_1.performance.now();
        // console.log(res);
        console.log(`Resampling file ${audioTest.inFile} with ${audioTest.channels} channel(s) from ${audioTest.inRate}Hz to ${audioTest.outRate}Hz with quality ${audioTest.quality || 4}`);
        console.log(`Resampled in ${Math.floor(end - start)}ms, factor ${(audioTest.pcmData.length / (audioTest.inRate / 1000) / 2 / audioTest.channels) / (end - start)}`);
        console.log(`Input stream: ${audioTest.pcmData.length} bytes, ${audioTest.pcmData.length / audioTest.inRate / 2 / audioTest.channels}s`);
        console.log(`Output stream: ${res.length} bytes, ${res.length / audioTest.outRate / 2 / audioTest.channels}s`);
        console.log();
        const inputDuration = audioTest.pcmData.length / audioTest.inRate / 2 / audioTest.channels;
        const outputDuration = res.length / audioTest.outRate / 2 / audioTest.channels;
        assert(Math.abs(inputDuration - outputDuration) < 0.01, `Stream duration not matching target, in: ${inputDuration}s != out:${outputDuration}`);
        // writeFileSync(path.resolve(__dirname, `../resources/${filename}_${audioTest.outRate}_${audioTest.quality || 7}_output.pcm`), res);
    }
};
const streamBasedTest = async () => {
    console.log('=================');
    console.log('Tranform Stream Test');
    console.log('=================');
    for (const audioTest of test_utils_1.audioTests) {
        console.log(`Resampling file ${audioTest.inFile} with ${audioTest.channels} channel(s) from ${audioTest.inRate}Hz to ${audioTest.outRate}Hz with quality ${audioTest.quality || 4}`);
        const readFileStream = fs_1.createReadStream(audioTest.inFile);
        const transformStream = new index_1.SoxrResamplerTransform(audioTest.channels, audioTest.inRate, audioTest.outRate, index_1.SoxrDatatype.SOXR_INT16, index_1.SoxrDatatype.SOXR_INT16, audioTest.quality);
        let pcmData = Buffer.alloc(0);
        readFileStream.on('data', (d) => {
            pcmData = Buffer.concat([pcmData, d]);
        });
        let res = Buffer.alloc(0);
        transformStream.on('data', (d) => {
            res = Buffer.concat([res, d]);
        });
        const start = perf_hooks_1.performance.now();
        readFileStream.pipe(transformStream);
        await new Promise((r) => transformStream.on('end', r));
        const end = perf_hooks_1.performance.now();
        console.log(`Resampled in ${Math.floor(end - start)}ms, factor ${(pcmData.length / (audioTest.inRate / 1000) / 2 / audioTest.channels) / (end - start)}`);
        console.log(`Input stream: ${pcmData.length} bytes, ${pcmData.length / audioTest.inRate / 2 / audioTest.channels}s`);
        console.log(`Output stream: ${res.length} bytes, ${res.length / audioTest.outRate / 2 / audioTest.channels}s`);
        const inputDuration = pcmData.length / audioTest.inRate / 2 / audioTest.channels;
        const outputDuration = res.length / audioTest.outRate / 2 / audioTest.channels;
        assert(Math.abs(inputDuration - outputDuration) < 0.01, `Stream duration not matching target, in: ${inputDuration}s != out:${outputDuration}`);
        console.log();
    }
};
const smallChunksTest = async () => {
    console.log('=================');
    console.log('Small chunks Test');
    console.log('=================');
    for (const audioTest of test_utils_1.audioTests) {
        const chunkSize = (audioTest.inRate / 100) * 2 * audioTest.channels; // simulate 100 chunks per seconds
        console.log(`Resampling file ${audioTest.inFile} with ${audioTest.channels} channel(s) from ${audioTest.inRate}Hz to ${audioTest.outRate}Hz with quality ${audioTest.quality || 4}`);
        const resampler = new index_1.default(audioTest.channels, audioTest.inRate, audioTest.outRate, index_1.SoxrDatatype.SOXR_INT16, index_1.SoxrDatatype.SOXR_INT16, audioTest.quality);
        await resampler.init();
        const start = perf_hooks_1.performance.now();
        for (let i = 0; i * chunkSize < audioTest.pcmData.length; i++) {
            const chunk = audioTest.pcmData.slice(i * chunkSize, (i + 1) * chunkSize);
            const res = resampler.processChunk(chunk);
            // if (res.length !== (audioTest.outRate / 100) * 2 * audioTest.channels) {
            //   console.log('Diff length:', res.length);
            // }
        }
        const end = perf_hooks_1.performance.now();
        console.log(`Resampled in ${Math.floor(end - start)}ms, factor ${(audioTest.pcmData.length / (audioTest.inRate / 1000) / 2 / audioTest.channels) / (end - start)}`);
        console.log();
    }
};
const inBufferTest = async () => {
    console.log('=================');
    console.log('In buffer small chunks test');
    console.log('=================');
    const outputBuffer = new Uint8Array(2 * 1024 * 1024); // 2MB, should be enough for this test
    for (const audioTest of test_utils_1.audioTests) {
        const chunkSize = (audioTest.inRate / 100) * 2 * audioTest.channels; // simulate 100 chunks per seconds
        console.log(`Resampling file ${audioTest.inFile} with ${audioTest.channels} channel(s) from ${audioTest.inRate}Hz to ${audioTest.outRate}Hz with quality ${audioTest.quality || 4}`);
        const resampler = new index_1.default(audioTest.channels, audioTest.inRate, audioTest.outRate, index_1.SoxrDatatype.SOXR_INT16, index_1.SoxrDatatype.SOXR_INT16, audioTest.quality);
        await resampler.init();
        const start = perf_hooks_1.performance.now();
        for (let i = 0; i * chunkSize < audioTest.pcmData.length; i++) {
            const chunk = audioTest.pcmData.slice(i * chunkSize, (i + 1) * chunkSize);
            resampler.processChunk(chunk, outputBuffer);
        }
        const end = perf_hooks_1.performance.now();
        console.log(`Resampled in ${Math.floor(end - start)}ms, factor ${(audioTest.pcmData.length / (audioTest.inRate / 1000) / 2 / audioTest.channels) / (end - start)}`);
        console.log();
    }
};
const typeChangeTest = async () => {
    console.log('=================');
    console.log('Type change test');
    console.log('=================');
    for (const audioTest of test_utils_1.audioTests) {
        console.log(`Resampling file ${audioTest.inFile} with ${audioTest.channels} channel(s) from ${audioTest.inRate}Hz to ${audioTest.outRate}Hz with quality ${audioTest.quality || 4}`);
        const resampler = new index_1.default(audioTest.channels, audioTest.inRate, audioTest.outRate, index_1.SoxrDatatype.SOXR_INT16, index_1.SoxrDatatype.SOXR_FLOAT32, audioTest.quality);
        await resampler.init();
        const filename = path_1.default.parse(audioTest.inFile).name;
        const start = perf_hooks_1.performance.now();
        const res = Buffer.concat([resampler.processChunk(audioTest.pcmData), resampler.processChunk(null)]);
        const end = perf_hooks_1.performance.now();
        console.log(`Resampled in ${Math.floor(end - start)}ms, factor ${(audioTest.pcmData.length / (audioTest.inRate / 1000) / 2 / audioTest.channels) / (end - start)}`);
        console.log(`Input stream: ${audioTest.pcmData.length} bytes, ${audioTest.pcmData.length / audioTest.inRate / 2 / audioTest.channels}s`);
        console.log(`Output stream: ${res.length} bytes, ${res.length / audioTest.outRate / Float32Array.BYTES_PER_ELEMENT / audioTest.channels}s`);
        const inputDuration = audioTest.pcmData.length / audioTest.inRate / 2 / audioTest.channels;
        const outputDuration = res.length / audioTest.outRate / Float32Array.BYTES_PER_ELEMENT / audioTest.channels;
        assert(Math.abs(inputDuration - outputDuration) < 0.01, `Stream duration not matching target, in: ${inputDuration}s != out:${outputDuration}`);
        console.log();
        fs_1.writeFileSync(path_1.default.resolve(__dirname, `../resources/${filename}_${audioTest.outRate}_${audioTest.quality || 7}_output.pcm`), res);
    }
};
exports.parallelTest = async () => {
    console.log('=================');
    console.log('Parallel Test');
    console.log('=================');
    const start = perf_hooks_1.performance.now();
    const results = await Promise.all(test_utils_1.audioTests.map(async (audioTest) => {
        const resampler = new soxr_resampler_thread_1.SoxrResamplerThread(audioTest.channels, audioTest.inRate, audioTest.outRate, index_1.SoxrDatatype.SOXR_INT16, index_1.SoxrDatatype.SOXR_INT16, audioTest.quality);
        await resampler.init();
        const filename = path_1.default.parse(audioTest.inFile).name;
        const res = Buffer.concat([
            await resampler.processChunk(audioTest.pcmData),
            await resampler.processChunk(null)
        ]);
        const inputDuration = audioTest.pcmData.length / audioTest.inRate / 2 / audioTest.channels;
        const outputDuration = res.length / audioTest.outRate / 2 / audioTest.channels;
        assert(Math.abs(inputDuration - outputDuration) < 0.01, `Stream duration not matching target, in: ${inputDuration}s != out:${outputDuration}`);
        resampler.destroy();
        // writeFileSync(path.resolve(__dirname, `../resources/${filename}_${audioTest.outRate}_${audioTest.quality || 7}_output.pcm`), res);
        return res;
    }));
    const end = perf_hooks_1.performance.now();
    console.log(`Resampled all ${test_utils_1.audioTests.length} files in ${Math.floor(end - start)}ms`);
    // console.log(results);
};
const main = async () => {
    await exports.promiseBasedTest();
    await streamBasedTest();
    await smallChunksTest();
    await inBufferTest();
    await typeChangeTest();
    await exports.parallelTest();
};
main().catch((e) => {
    console.error(e);
    process.exit(1);
});
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGVzdC5qcyIsInNvdXJjZVJvb3QiOiIvIiwic291cmNlcyI6WyJ0ZXN0LnRzIl0sIm5hbWVzIjpbXSwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQkFBa0Q7QUFDbEQsdUNBQXVDO0FBQ3ZDLDJDQUF3QztBQUN4QyxnREFBd0I7QUFDeEIsNkNBQTBDO0FBRTFDLGlEQUF5RjtBQUN6RixtRUFBOEQ7QUFFOUQsTUFBTSxNQUFNLEdBQUcsQ0FBQyxTQUFTLEVBQUUsT0FBTyxFQUFFLEVBQUU7SUFDcEMsSUFBSSxDQUFDLFNBQVMsRUFBRTtRQUNkLE1BQU0sSUFBSSxLQUFLLENBQUMsT0FBTyxDQUFDLENBQUM7S0FDMUI7QUFDSCxDQUFDLENBQUE7QUFFWSxRQUFBLGdCQUFnQixHQUFHLEtBQUssSUFBSSxFQUFFO0lBQ3pDLEtBQUssTUFBTSxTQUFTLElBQUksdUJBQVUsRUFBRTtRQUNsQyxNQUFNLFNBQVMsR0FBRyxJQUFJLGVBQWEsQ0FDakMsU0FBUyxDQUFDLFFBQVEsRUFDbEIsU0FBUyxDQUFDLE1BQU0sRUFDaEIsU0FBUyxDQUFDLE9BQU8sRUFDakIsb0JBQVksQ0FBQyxVQUFVLEVBQ3ZCLG9CQUFZLENBQUMsVUFBVSxFQUN2QixTQUFTLENBQUMsT0FBTyxDQUNsQixDQUFDO1FBQ0YsTUFBTSxTQUFTLENBQUMsSUFBSSxFQUFFLENBQUM7UUFDdkIsTUFBTSxRQUFRLEdBQUcsY0FBSSxDQUFDLEtBQUssQ0FBQyxTQUFTLENBQUMsTUFBTSxDQUFDLENBQUMsSUFBSSxDQUFDO1FBRW5ELE1BQU0sS0FBSyxHQUFHLHdCQUFXLENBQUMsR0FBRyxFQUFFLENBQUM7UUFDaEMsTUFBTSxHQUFHLEdBQUcsTUFBTSxDQUFDLE1BQU0sQ0FBQyxDQUFDLFNBQVMsQ0FBQyxZQUFZLENBQUMsU0FBUyxDQUFDLE9BQU8sQ0FBQyxFQUFFLFNBQVMsQ0FBQyxZQUFZLENBQUMsSUFBSSxDQUFDLENBQUMsQ0FBQyxDQUFDO1FBQ3JHLE1BQU0sR0FBRyxH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QUFJLENBQUMsS0FBSyxDQUFDLEdBQUcsR0FBRyxLQUFLLENBQUMsSUFBSSxDQUFDLENBQUM7SUFDeEYsd0JBQXdCO0FBQzFCLENBQUMsQ0FBQTtBQUVELE1BQU0sSUFBSSxHQUFHLEtBQUssSUFBSSxFQUFFO0lBQ3RCLE1BQU0sd0JBQWdCLEVBQUUsQ0FBQztJQUN6QixNQUFNLGVBQWUsRUFBRSxDQUFDO0lBQ3hCLE1BQU0sZUFBZSxFQUFFLENBQUM7SUFDeEIsTUFBTSxZQUFZLEVBQUUsQ0FBQztJQUNyQixNQUFNLGNBQWMsRUFBRSxDQUFDO0lBQ3ZCLE1BQU0sb0JBQVksRUFBRSxDQUFDO0FBQ3ZCLENBQUMsQ0FBQztBQUVGLElBQUksRUFBRSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsRUFBRSxFQUFFO0lBQ2pCLE9BQU8sQ0FBQyxLQUFLLENBQUMsQ0FBQyxDQUFDLENBQUM7SUFDakIsT0FBTyxDQUFDLElBQUksQ0FBQyxDQUFDLENBQUMsQ0FBQztBQUNsQixDQUFDLENBQUMsQ0FBQSIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7d3JpdGVGaWxlU3luYyxjcmVhdGVSZWFkU3RyZWFtfSBmcm9tICdmcyc7XG4vLyBjb25zdCB7cHJvbWlzaWZ5fSA9IHJlcXVpcmUoJ3V0aWwnKTtcbmltcG9ydCB7IHBlcmZvcm1hbmNlIH0gZnJvbSAncGVyZl9ob29rcydcbmltcG9ydCBwYXRoIGZyb20gJ3BhdGgnO1xuaW1wb3J0IHsgYXVkaW9UZXN0cyB9IGZyb20gJy4vdGVzdF91dGlscyc7XG5cbmltcG9ydCBTb3hyUmVzYW1wbGVyLCB7U294clJlc2FtcGxlclRyYW5zZm9ybSwgU294ckRhdGF0eXBlLCBTb3hyUXVhbGl0eX0gZnJvbSAnLi9pbmRleCc7XG5pbXBvcnQgeyBTb3hyUmVzYW1wbGVyVGhyZWFkIH0gZnJvbSAnLi9zb3hyX3Jlc2FtcGxlcl90aHJlYWQnO1xuXG5jb25zdCBhc3NlcnQgPSAoY29uZGl0aW9uLCBtZXNzYWdlKSA9PiB7XG4gIGlmICghY29uZGl0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKG1lc3NhZ2UpO1xuICB9XG59XG5cbmV4cG9ydCBjb25zdCBwcm9taXNlQmFzZWRUZXN0ID0gYXN5bmMgKCkgPT4ge1xuICBmb3IgKGNvbnN0IGF1ZGlvVGVzdCBvZiBhdWRpb1Rlc3RzKSB7XG4gICAgY29uc3QgcmVzYW1wbGVyID0gbmV3IFNveHJSZXNhbXBsZXIoXG4gICAgICBhdWRpb1Rlc3QuY2hhbm5lbHMsXG4gICAgICBhdWRpb1Rlc3QuaW5SYXRlLFxuICAgICAgYXVkaW9UZXN0Lm91dFJhdGUsXG4gICAgICBTb3hyRGF0YXR5cGUuU09YUl9JTlQxNixcbiAgICAgIFNveHJEYXRhdHlwZS5TT1hSX0lOVDE2LFxuICAgICAgYXVkaW9UZXN0LnF1YWxpdHksXG4gICAgKTtcbiAgICBhd2FpdCByZXNhbXBsZXIuaW5pdCgpO1xuICAgIGNvbnN0IGZpbGVuYW1lID0gcGF0aC5wYXJzZShhdWRpb1Rlc3QuaW5GaWxlKS5uYW1lO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBjb25zdCByZXMgPSBCdWZmZXIuY29uY2F0KFtyZXNhbXBsZXIucHJvY2Vzc0NodW5rKGF1ZGlvVGVzdC5wY21EYXRhKSwgcmVzYW1wbGVyLnByb2Nlc3NDaHVuayhudWxsKV0pO1xuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIC8vIGNvbnNvbGUubG9nKHJlcyk7XG4gICAgY29uc29sZS5sb2coYFJlc2FtcGxpbmcgZmlsZSAke2F1ZGlvVGVzdC5pbkZpbGV9IHdpdGggJHthdWRpb1Rlc3QuY2hhbm5lbHN9IGNoYW5uZWwocykgZnJvbSAke2F1ZGlvVGVzdC5pblJhdGV9SHogdG8gJHthdWRpb1Rlc3Qub3V0UmF0ZX1IeiB3aXRoIHF1YWxpdHkgJHthdWRpb1Rlc3QucXVhbGl0eSB8fCA0fWApO1xuICAgIGNvbnNvbGUubG9nKGBSZXNhbXBsZWQgaW4gJHtNYXRoLmZsb29yKGVuZCAtIHN0YXJ0KX1tcywgZmFjdG9yICR7KGF1ZGlvVGVzdC5wY21EYXRhLmxlbmd0aCAvIChhdWRpb1Rlc3QuaW5SYXRlIC8gMTAwMCkgLyAyIC8gYXVkaW9UZXN0LmNoYW5uZWxzKSAvIChlbmQgLSBzdGFydCl9YCk7XG4gICAgY29uc29sZS5sb2coYElucHV0IHN0cmVhbTogJHthdWRpb1Rlc3QucGNtRGF0YS5sZW5ndGh9IGJ5dGVzLCAke2F1ZGlvVGVzdC5wY21EYXRhLmxlbmd0aCAvIGF1ZGlvVGVzdC5pblJhdGUgLyAyIC8gYXVkaW9UZXN0LmNoYW5uZWxzfXNgKTtcbiAgICBjb25zb2xlLmxvZyhgT3V0cHV0IHN0cmVhbTogJHtyZXMubGVuZ3RofSBieXRlcywgJHtyZXMubGVuZ3RoIC8gYXVkaW9UZXN0Lm91dFJhdGUgLyAyIC8gYXVkaW9UZXN0LmNoYW5uZWxzfXNgKTtcbiAgICBjb25zb2xlLmxvZygpO1xuXG4gICAgY29uc3QgaW5wdXREdXJhdGlvbiA9IGF1ZGlvVGVzdC5wY21EYXRhLmxlbmd0aCAvIGF1ZGlvVGVzdC5pblJhdGUgLyAyIC8gYXVkaW9UZXN0LmNoYW5uZWxzO1xuICAgIGNvbnN0IG91dHB1dER1cmF0aW9uID0gcmVzLmxlbmd0aCAvIGF1ZGlvVGVzdC5vdXRSYXRlIC8gMiAvIGF1ZGlvVGVzdC5jaGFubmVscztcbiAgICBhc3NlcnQoTWF0aC5hYnMoaW5wdXREdXJhdGlvbiAtIG91dHB1dER1cmF0aW9uKSA8IDAuMDEsIGBTdHJlYW0gZHVyYXRpb24gbm90IG1hdGNoaW5nIHRhcmdldCwgaW46ICR7aW5wdXREdXJhdGlvbn1zICE9IG91dDoke291dHB1dER1cmF0aW9ufWApO1xuICAgIC8vIHdyaXRlRmlsZVN5bmMocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgYC4uL3Jlc291cmNlcy8ke2ZpbGVuYW1lfV8ke2F1ZGlvVGVzdC5vdXRSYXRlfV8ke2F1ZGlvVGVzdC5xdWFsaXR5IHx8IDd9X291dHB1dC5wY21gKSwgcmVzKTtcbiAgfVxufVxuXG5jb25zdCBzdHJlYW1CYXNlZFRlc3QgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PScpO1xuICBjb25zb2xlLmxvZygnVHJhbmZvcm0gU3RyZWFtIFRlc3QnKTtcbiAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09Jyk7XG5cbiAgZm9yIChjb25zdCBhdWRpb1Rlc3Qgb2YgYXVkaW9UZXN0cykge1xuICAgIGNvbnNvbGUubG9nKGBSZXNhbXBsaW5nIGZpbGUgJHthdWRpb1Rlc3QuaW5GaWxlfSB3aXRoICR7YXVkaW9UZXN0LmNoYW5uZWxzfSBjaGFubmVsKHMpIGZyb20gJHthdWRpb1Rlc3QuaW5SYXRlfUh6IHRvICR7YXVkaW9UZXN0Lm91dFJhdGV9SHogd2l0aCBxdWFsaXR5ICR7YXVkaW9UZXN0LnF1YWxpdHkgfHwgNH1gKTtcbiAgICBjb25zdCByZWFkRmlsZVN0cmVhbSA9IGNyZWF0ZVJlYWRTdHJlYW0oYXVkaW9UZXN0LmluRmlsZSk7XG4gICAgY29uc3QgdHJhbnNmb3JtU3RyZWFtID0gbmV3IFNveHJSZXNhbXBsZXJUcmFuc2Zvcm0oXG4gICAgICBhdWRpb1Rlc3QuY2hhbm5lbHMsXG4gICAgICBhdWRpb1Rlc3QuaW5SYXRlLFxuICAgICAgYXVkaW9UZXN0Lm91dFJhdGUsXG4gICAgICBTb3hyRGF0YXR5cGUuU09YUl9JTlQxNixcbiAgICAgIFNveHJEYXRhdHlwZS5TT1hSX0lOVDE2LFxuICAgICAgYXVkaW9UZXN0LnF1YWxpdHksXG4gICAgKTtcbiAgICBsZXQgcGNtRGF0YSA9IEJ1ZmZlci5hbGxvYygwKTtcbiAgICByZWFkRmlsZVN0cmVhbS5vbignZGF0YScsIChkKSA9PiB7XG4gICAgICBwY21EYXRhID0gQnVmZmVyLmNvbmNhdChbIHBjbURhdGEsIGQgYXMgQnVmZmVyIF0pO1xuICAgIH0pO1xuICAgIGxldCByZXMgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgdHJhbnNmb3JtU3RyZWFtLm9uKCdkYXRhJywgKGQpID0+IHtcbiAgICAgIHJlcyA9IEJ1ZmZlci5jb25jYXQoWyByZXMsIGQgYXMgQnVmZmVyIF0pO1xuICAgIH0pO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICByZWFkRmlsZVN0cmVhbS5waXBlKHRyYW5zZm9ybVN0cmVhbSk7XG4gICAgYXdhaXQgbmV3IFByb21pc2UoKHIpID0+IHRyYW5zZm9ybVN0cmVhbS5vbignZW5kJywgcikpO1xuICAgIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnNvbGUubG9nKGBSZXNhbXBsZWQgaW4gJHtNYXRoLmZsb29yKGVuZCAtIHN0YXJ0KX1tcywgZmFjdG9yICR7KHBjbURhdGEubGVuZ3RoIC8gKGF1ZGlvVGVzdC5pblJhdGUgLyAxMDAwKSAvIDIgLyBhdWRpb1Rlc3QuY2hhbm5lbHMpIC8gKGVuZCAtIHN0YXJ0KX1gKTtcbiAgICBjb25zb2xlLmxvZyhgSW5wdXQgc3RyZWFtOiAke3BjbURhdGEubGVuZ3RofSBieXRlcywgJHtwY21EYXRhLmxlbmd0aCAvIGF1ZGlvVGVzdC5pblJhdGUgLyAyIC8gYXVkaW9UZXN0LmNoYW5uZWxzfXNgKTtcbiAgICBjb25zb2xlLmxvZyhgT3V0cHV0IHN0cmVhbTogJHtyZXMubGVuZ3RofSBieXRlcywgJHtyZXMubGVuZ3RoIC8gYXVkaW9UZXN0Lm91dFJhdGUgLyAyIC8gYXVkaW9UZXN0LmNoYW5uZWxzfXNgKTtcblxuICAgIGNvbnN0IGlucHV0RHVyYXRpb24gPSBwY21EYXRhLmxlbmd0aCAvIGF1ZGlvVGVzdC5pblJhdGUgLyAyIC8gYXVkaW9UZXN0LmNoYW5uZWxzO1xuICAgIGNvbnN0IG91dHB1dER1cmF0aW9uID0gcmVzLmxlbmd0aCAvIGF1ZGlvVGVzdC5vdXRSYXRlIC8gMiAvIGF1ZGlvVGVzdC5jaGFubmVscztcbiAgICBhc3NlcnQoTWF0aC5hYnMoaW5wdXREdXJhdGlvbiAtIG91dHB1dER1cmF0aW9uKSA8IDAuMDEsIGBTdHJlYW0gZHVyYXRpb24gbm90IG1hdGNoaW5nIHRhcmdldCwgaW46ICR7aW5wdXREdXJhdGlvbn1zICE9IG91dDoke291dHB1dER1cmF0aW9ufWApO1xuICAgIGNvbnNvbGUubG9nKCk7XG4gIH1cbn1cblxuY29uc3Qgc21hbGxDaHVua3NUZXN0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PT0nKTtcbiAgY29uc29sZS5sb2coJ1NtYWxsIGNodW5rcyBUZXN0Jyk7XG4gIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PScpO1xuXG4gIGZvciAoY29uc3QgYXVkaW9UZXN0IG9mIGF1ZGlvVGVzdHMpIHtcbiAgICBjb25zdCBjaHVua1NpemUgPSAoYXVkaW9UZXN0LmluUmF0ZSAvIDEwMCkgKiAyICogYXVkaW9UZXN0LmNoYW5uZWxzOyAvLyBzaW11bGF0ZSAxMDAgY2h1bmtzIHBlciBzZWNvbmRzXG4gICAgY29uc29sZS5sb2coYFJlc2FtcGxpbmcgZmlsZSAke2F1ZGlvVGVzdC5pbkZpbGV9IHdpdGggJHthdWRpb1Rlc3QuY2hhbm5lbHN9IGNoYW5uZWwocykgZnJvbSAke2F1ZGlvVGVzdC5pblJhdGV9SHogdG8gJHthdWRpb1Rlc3Qub3V0UmF0ZX1IeiB3aXRoIHF1YWxpdHkgJHthdWRpb1Rlc3QucXVhbGl0eSB8fCA0fWApO1xuICAgIGNvbnN0IHJlc2FtcGxlciA9IG5ldyBTb3hyUmVzYW1wbGVyKFxuICAgICAgYXVkaW9UZXN0LmNoYW5uZWxzLFxuICAgICAgYXVkaW9UZXN0LmluUmF0ZSxcbiAgICAgIGF1ZGlvVGVzdC5vdXRSYXRlLFxuICAgICAgU294ckRhdGF0eXBlLlNPWFJfSU5UMTYsXG4gICAgICBTb3hyRGF0YXR5cGUuU09YUl9JTlQxNixcbiAgICAgIGF1ZGlvVGVzdC5xdWFsaXR5LFxuICAgICk7XG4gICAgYXdhaXQgcmVzYW1wbGVyLmluaXQoKTtcblxuICAgIGNvbnN0IHN0YXJ0ID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgKiBjaHVua1NpemUgPCBhdWRpb1Rlc3QucGNtRGF0YS5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3QgY2h1bmsgPSBhdWRpb1Rlc3QucGNtRGF0YS5zbGljZShpICogY2h1bmtTaXplLCAoaSArIDEpICogY2h1bmtTaXplKTtcbiAgICAgIGNvbnN0IHJlcyA9IHJlc2FtcGxlci5wcm9jZXNzQ2h1bmsoY2h1bmspO1xuICAgICAgLy8gaWYgKHJlcy5sZW5ndGggIT09IChhdWRpb1Rlc3Qub3V0UmF0ZSAvIDEwMCkgKiAyICogYXVkaW9UZXN0LmNoYW5uZWxzKSB7XG4gICAgICAvLyAgIGNvbnNvbGUubG9nKCdEaWZmIGxlbmd0aDonLCByZXMubGVuZ3RoKTtcbiAgICAgIC8vIH1cbiAgICB9XG4gICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBjb25zb2xlLmxvZyhgUmVzYW1wbGVkIGluICR7TWF0aC5mbG9vcihlbmQgLSBzdGFydCl9bXMsIGZhY3RvciAkeyhhdWRpb1Rlc3QucGNtRGF0YS5sZW5ndGggLyAoYXVkaW9UZXN0LmluUmF0ZSAvIDEwMDApIC8gMiAvIGF1ZGlvVGVzdC5jaGFubmVscykgLyAoZW5kIC0gc3RhcnQpfWApO1xuXG4gICAgY29uc29sZS5sb2coKTtcbiAgfVxufVxuXG5jb25zdCBpbkJ1ZmZlclRlc3QgPSBhc3luYyAoKSA9PiB7XG4gIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PScpO1xuICBjb25zb2xlLmxvZygnSW4gYnVmZmVyIHNtYWxsIGNodW5rcyB0ZXN0Jyk7XG4gIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PScpO1xuXG4gIGNvbnN0IG91dHB1dEJ1ZmZlciA9IG5ldyBVaW50OEFycmF5KDIgKiAxMDI0ICogMTAyNCk7IC8vIDJNQiwgc2hvdWxkIGJlIGVub3VnaCBmb3IgdGhpcyB0ZXN0XG5cbiAgZm9yIChjb25zdCBhdWRpb1Rlc3Qgb2YgYXVkaW9UZXN0cykge1xuICAgIGNvbnN0IGNodW5rU2l6ZSA9IChhdWRpb1Rlc3QuaW5SYXRlIC8gMTAwKSAqIDIgKiBhdWRpb1Rlc3QuY2hhbm5lbHM7IC8vIHNpbXVsYXRlIDEwMCBjaHVua3MgcGVyIHNlY29uZHNcbiAgICBjb25zb2xlLmxvZyhgUmVzYW1wbGluZyBmaWxlICR7YXVkaW9UZXN0LmluRmlsZX0gd2l0aCAke2F1ZGlvVGVzdC5jaGFubmVsc30gY2hhbm5lbChzKSBmcm9tICR7YXVkaW9UZXN0LmluUmF0ZX1IeiB0byAke2F1ZGlvVGVzdC5vdXRSYXRlfUh6IHdpdGggcXVhbGl0eSAke2F1ZGlvVGVzdC5xdWFsaXR5IHx8IDR9YCk7XG4gICAgY29uc3QgcmVzYW1wbGVyID0gbmV3IFNveHJSZXNhbXBsZXIoXG4gICAgICBhdWRpb1Rlc3QuY2hhbm5lbHMsXG4gICAgICBhdWRpb1Rlc3QuaW5SYXRlLFxuICAgICAgYXVkaW9UZXN0Lm91dFJhdGUsXG4gICAgICBTb3hyRGF0YXR5cGUuU09YUl9JTlQxNixcbiAgICAgIFNveHJEYXRhdHlwZS5TT1hSX0lOVDE2LFxuICAgICAgYXVkaW9UZXN0LnF1YWxpdHksXG4gICAgKTtcbiAgICBhd2FpdCByZXNhbXBsZXIuaW5pdCgpO1xuXG4gICAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgICBmb3IgKGxldCBpID0gMDsgaSAqIGNodW5rU2l6ZSA8IGF1ZGlvVGVzdC5wY21EYXRhLmxlbmd0aDsgaSsrKSB7XG4gICAgICBjb25zdCBjaHVuayA9IGF1ZGlvVGVzdC5wY21EYXRhLnNsaWNlKGkgKiBjaHVua1NpemUsIChpICsgMSkgKiBjaHVua1NpemUpO1xuICAgICAgcmVzYW1wbGVyLnByb2Nlc3NDaHVuayhjaHVuaywgb3V0cHV0QnVmZmVyKTtcbiAgICB9XG4gICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG5cbiAgICBjb25zb2xlLmxvZyhgUmVzYW1wbGVkIGluICR7TWF0aC5mbG9vcihlbmQgLSBzdGFydCl9bXMsIGZhY3RvciAkeyhhdWRpb1Rlc3QucGNtRGF0YS5sZW5ndGggLyAoYXVkaW9UZXN0LmluUmF0ZSAvIDEwMDApIC8gMiAvIGF1ZGlvVGVzdC5jaGFubmVscykgLyAoZW5kIC0gc3RhcnQpfWApO1xuXG4gICAgY29uc29sZS5sb2coKTtcbiAgfVxufVxuXG5jb25zdCB0eXBlQ2hhbmdlVGVzdCA9IGFzeW5jICgpID0+IHtcbiAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09Jyk7XG4gIGNvbnNvbGUubG9nKCdUeXBlIGNoYW5nZSB0ZXN0Jyk7XG4gIGNvbnNvbGUubG9nKCc9PT09PT09PT09PT09PT09PScpO1xuXG4gIGZvciAoY29uc3QgYXVkaW9UZXN0IG9mIGF1ZGlvVGVzdHMpIHtcbiAgICBjb25zb2xlLmxvZyhgUmVzYW1wbGluZyBmaWxlICR7YXVkaW9UZXN0LmluRmlsZX0gd2l0aCAke2F1ZGlvVGVzdC5jaGFubmVsc30gY2hhbm5lbChzKSBmcm9tICR7YXVkaW9UZXN0LmluUmF0ZX1IeiB0byAke2F1ZGlvVGVzdC5vdXRSYXRlfUh6IHdpdGggcXVhbGl0eSAke2F1ZGlvVGVzdC5xdWFsaXR5IHx8IDR9YCk7XG4gICAgY29uc3QgcmVzYW1wbGVyID0gbmV3IFNveHJSZXNhbXBsZXIoXG4gICAgICBhdWRpb1Rlc3QuY2hhbm5lbHMsXG4gICAgICBhdWRpb1Rlc3QuaW5SYXRlLFxuICAgICAgYXVkaW9UZXN0Lm91dFJhdGUsXG4gICAgICBTb3hyRGF0YXR5cGUuU09YUl9JTlQxNixcbiAgICAgIFNveHJEYXRhdHlwZS5TT1hSX0ZMT0FUMzIsXG4gICAgICBhdWRpb1Rlc3QucXVhbGl0eSxcbiAgICApO1xuICAgIGF3YWl0IHJlc2FtcGxlci5pbml0KCk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLnBhcnNlKGF1ZGlvVGVzdC5pbkZpbGUpLm5hbWU7XG5cbiAgICBjb25zdCBzdGFydCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICAgIGNvbnN0IHJlcyA9IEJ1ZmZlci5jb25jYXQoW3Jlc2FtcGxlci5wcm9jZXNzQ2h1bmsoYXVkaW9UZXN0LnBjbURhdGEpLCByZXNhbXBsZXIucHJvY2Vzc0NodW5rKG51bGwpXSk7XG4gICAgY29uc3QgZW5kID0gcGVyZm9ybWFuY2Uubm93KCk7XG4gICAgY29uc29sZS5sb2coYFJlc2FtcGxlZCBpbiAke01hdGguZmxvb3IoZW5kIC0gc3RhcnQpfW1zLCBmYWN0b3IgJHsoYXVkaW9UZXN0LnBjbURhdGEubGVuZ3RoIC8gKGF1ZGlvVGVzdC5pblJhdGUgLyAxMDAwKSAvIDIgLyBhdWRpb1Rlc3QuY2hhbm5lbHMpIC8gKGVuZCAtIHN0YXJ0KX1gKTtcbiAgICBjb25zb2xlLmxvZyhgSW5wdXQgc3RyZWFtOiAke2F1ZGlvVGVzdC5wY21EYXRhLmxlbmd0aH0gYnl0ZXMsICR7YXVkaW9UZXN0LnBjbURhdGEubGVuZ3RoIC8gYXVkaW9UZXN0LmluUmF0ZSAvIDIgLyBhdWRpb1Rlc3QuY2hhbm5lbHN9c2ApO1xuICAgIGNvbnNvbGUubG9nKGBPdXRwdXQgc3RyZWFtOiAke3Jlcy5sZW5ndGh9IGJ5dGVzLCAke3Jlcy5sZW5ndGggLyBhdWRpb1Rlc3Qub3V0UmF0ZSAvIEZsb2F0MzJBcnJheS5CWVRFU19QRVJfRUxFTUVOVCAvIGF1ZGlvVGVzdC5jaGFubmVsc31zYCk7XG5cbiAgICBjb25zdCBpbnB1dER1cmF0aW9uID0gYXVkaW9UZXN0LnBjbURhdGEubGVuZ3RoIC8gYXVkaW9UZXN0LmluUmF0ZSAvIDIgLyBhdWRpb1Rlc3QuY2hhbm5lbHM7XG4gICAgY29uc3Qgb3V0cHV0RHVyYXRpb24gPSByZXMubGVuZ3RoIC8gYXVkaW9UZXN0Lm91dFJhdGUgLyBGbG9hdDMyQXJyYXkuQllURVNfUEVSX0VMRU1FTlQgLyBhdWRpb1Rlc3QuY2hhbm5lbHM7XG4gICAgYXNzZXJ0KE1hdGguYWJzKGlucHV0RHVyYXRpb24gLSBvdXRwdXREdXJhdGlvbikgPCAwLjAxLCBgU3RyZWFtIGR1cmF0aW9uIG5vdCBtYXRjaGluZyB0YXJnZXQsIGluOiAke2lucHV0RHVyYXRpb259cyAhPSBvdXQ6JHtvdXRwdXREdXJhdGlvbn1gKTtcbiAgICBjb25zb2xlLmxvZygpO1xuICAgIHdyaXRlRmlsZVN5bmMocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgYC4uL3Jlc291cmNlcy8ke2ZpbGVuYW1lfV8ke2F1ZGlvVGVzdC5vdXRSYXRlfV8ke2F1ZGlvVGVzdC5xdWFsaXR5IHx8IDd9X291dHB1dC5wY21gKSwgcmVzKTtcbiAgfVxufVxuXG5leHBvcnQgY29uc3QgcGFyYWxsZWxUZXN0ID0gYXN5bmMgKCkgPT4ge1xuICBjb25zb2xlLmxvZygnPT09PT09PT09PT09PT09PT0nKTtcbiAgY29uc29sZS5sb2coJ1BhcmFsbGVsIFRlc3QnKTtcbiAgY29uc29sZS5sb2coJz09PT09PT09PT09PT09PT09Jyk7XG5cbiAgY29uc3Qgc3RhcnQgPSBwZXJmb3JtYW5jZS5ub3coKTtcbiAgY29uc3QgcmVzdWx0cyA9IGF3YWl0IFByb21pc2UuYWxsKGF1ZGlvVGVzdHMubWFwKGFzeW5jIChhdWRpb1Rlc3QpID0+IHtcbiAgICBjb25zdCByZXNhbXBsZXIgPSBuZXcgU294clJlc2FtcGxlclRocmVhZChcbiAgICAgIGF1ZGlvVGVzdC5jaGFubmVscyxcbiAgICAgIGF1ZGlvVGVzdC5pblJhdGUsXG4gICAgICBhdWRpb1Rlc3Qub3V0UmF0ZSxcbiAgICAgIFNveHJEYXRhdHlwZS5TT1hSX0lOVDE2LFxuICAgICAgU294ckRhdGF0eXBlLlNPWFJfSU5UMTYsXG4gICAgICBhdWRpb1Rlc3QucXVhbGl0eSxcbiAgICApO1xuICAgIGF3YWl0IHJlc2FtcGxlci5pbml0KCk7XG4gICAgY29uc3QgZmlsZW5hbWUgPSBwYXRoLnBhcnNlKGF1ZGlvVGVzdC5pbkZpbGUpLm5hbWU7XG5cbiAgICBjb25zdCByZXMgPSBCdWZmZXIuY29uY2F0KFtcbiAgICAgIGF3YWl0IHJlc2FtcGxlci5wcm9jZXNzQ2h1bmsoYXVkaW9UZXN0LnBjbURhdGEpLFxuICAgICAgYXdhaXQgcmVzYW1wbGVyLnByb2Nlc3NDaHVuayhudWxsKVxuICAgIF0pO1xuICAgIGNvbnN0IGlucHV0RHVyYXRpb24gPSBhdWRpb1Rlc3QucGNtRGF0YS5sZW5ndGggLyBhdWRpb1Rlc3QuaW5SYXRlIC8gMiAvIGF1ZGlvVGVzdC5jaGFubmVscztcbiAgICBjb25zdCBvdXRwdXREdXJhdGlvbiA9IHJlcy5sZW5ndGggLyBhdWRpb1Rlc3Qub3V0UmF0ZSAvIDIgLyBhdWRpb1Rlc3QuY2hhbm5lbHM7XG4gICAgYXNzZXJ0KE1hdGguYWJzKGlucHV0RHVyYXRpb24gLSBvdXRwdXREdXJhdGlvbikgPCAwLjAxLCBgU3RyZWFtIGR1cmF0aW9uIG5vdCBtYXRjaGluZyB0YXJnZXQsIGluOiAke2lucHV0RHVyYXRpb259cyAhPSBvdXQ6JHtvdXRwdXREdXJhdGlvbn1gKTtcbiAgICByZXNhbXBsZXIuZGVzdHJveSgpO1xuICAgIC8vIHdyaXRlRmlsZVN5bmMocGF0aC5yZXNvbHZlKF9fZGlybmFtZSwgYC4uL3Jlc291cmNlcy8ke2ZpbGVuYW1lfV8ke2F1ZGlvVGVzdC5vdXRSYXRlfV8ke2F1ZGlvVGVzdC5xdWFsaXR5IHx8IDd9X291dHB1dC5wY21gKSwgcmVzKTtcbiAgICByZXR1cm4gcmVzO1xuICB9KSk7XG4gIGNvbnN0IGVuZCA9IHBlcmZvcm1hbmNlLm5vdygpO1xuICBjb25zb2xlLmxvZyhgUmVzYW1wbGVkIGFsbCAke2F1ZGlvVGVzdHMubGVuZ3RofSBmaWxlcyBpbiAke01hdGguZmxvb3IoZW5kIC0gc3RhcnQpfW1zYCk7XG4gIC8vIGNvbnNvbGUubG9nKHJlc3VsdHMpO1xufVxuXG5jb25zdCBtYWluID0gYXN5bmMgKCkgPT4ge1xuICBhd2FpdCBwcm9taXNlQmFzZWRUZXN0KCk7XG4gIGF3YWl0IHN0cmVhbUJhc2VkVGVzdCgpO1xuICBhd2FpdCBzbWFsbENodW5rc1Rlc3QoKTtcbiAgYXdhaXQgaW5CdWZmZXJUZXN0KCk7XG4gIGF3YWl0IHR5cGVDaGFuZ2VUZXN0KCk7XG4gIGF3YWl0IHBhcmFsbGVsVGVzdCgpO1xufTtcblxubWFpbigpLmNhdGNoKChlKSA9PiB7XG4gIGNvbnNvbGUuZXJyb3IoZSk7XG4gIHByb2Nlc3MuZXhpdCgxKTtcbn0pXG4iXX0=